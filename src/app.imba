let emoji = ["ðŸ€","ðŸ","ðŸ‚","ðŸ˜ƒ","ðŸ˜„","ðŸ˜…","ðŸ˜†","ðŸ˜‡","ðŸ˜ˆ","ðŸ˜‰","ðŸ˜Š","ðŸ˜‹","ðŸ˜Œ","ðŸ˜","ðŸ˜Ž","ðŸ˜","ðŸ¤","ðŸ¤‘","ðŸ¤’","ðŸ¤“","ðŸ¤”","ðŸ¤•","ðŸ¤–","ðŸ¤—","ðŸ¤˜","ðŸ¤™","ðŸ¤š","ðŸ¤›","ðŸ¤œ","ðŸ¤","ðŸ¤ž","ðŸŒŸ","ðŸ ","ðŸŒ¡","ðŸ¢","ðŸ£","ðŸŒ¤","ðŸŒ¥","ðŸŒ¦","ðŸŒ§","ðŸŒ¨","ðŸŒ©","ðŸŒª","ðŸ˜«","ðŸ˜¬","ðŸ˜­","ðŸ˜®","ðŸ˜¯","ðŸ˜°","ðŸ˜±","ðŸ²","ðŸ³","ðŸ´","ðŸµ","ðŸ¶","ðŸ·","ðŸ¸","ðŸ¹","ðŸº","ðŸ»","ðŸ¼","ðŸ½","ðŸŒ¾","ðŸŒ¿","ðŸ€","ðŸ","ðŸ‚","ðŸƒ","ðŸ„","ðŸ…","ðŸ†","ðŸ‡","ðŸˆ","ðŸ‰","ðŸŠ","ðŸ‹","ðŸŒ","ðŸ","ðŸŽ","ðŸ","ðŸ¥","ðŸ¥‘","ðŸ’","ðŸ“","ðŸ”","ðŸ•","ðŸ–","ðŸ—","ðŸ˜","ðŸ™","ðŸš","ðŸ›","ðŸœ","ðŸ","ðŸž","ðŸŸ","ðŸ ","ðŸ¡","ðŸ¢","ðŸ£","ðŸ¤","ðŸ¥","ðŸ¦","ðŸ§","ðŸ¨","ðŸ©","ðŸª","ðŸ«","ðŸ¬","ðŸ­","ðŸ®","ðŸ¯","ðŸ°","ðŸ±","ðŸ²","ðŸ³","ðŸ´","ðŸµ","ðŸ¶","ðŸ·","ðŸ¸","ðŸ¹","ðŸº","ðŸ»","ðŸ¼","ðŸ½","ðŸ¾","ðŸ¿","ðŸŽ€","ðŸŽ","ðŸŽ‚","ðŸŽƒ","ðŸŽ„","ðŸŽ…","ðŸ¦†","ðŸ’‡","ðŸ¦ˆ","ðŸ¦‰","ðŸ¦Š","ðŸ¦‹","ðŸ¦Œ","ðŸ¦","ðŸ¦Ž","ðŸ’","ðŸ’","ðŸ’‘","ðŸ’’","ðŸ’“","ðŸ’”","ðŸ’•","ðŸŽ–","ðŸŽ—","ðŸ’˜","ðŸš™","ðŸšš","ðŸš›","ðŸšœ","ðŸš","ðŸšž","ðŸšŸ","ðŸš ","ðŸš¡","ðŸš¢","ðŸš£","ðŸš¤","ðŸ’¥","ðŸš¦","ðŸš§","ðŸš¨","ðŸŽ©","ðŸŽª","ðŸŽ«","ðŸŽ¬","ðŸŽ­","ðŸŽ®","ðŸŽ¯","ðŸŽ°","ðŸŽ±","ðŸŽ²","ðŸŽ³","ðŸŽ´","ðŸŽµ","ðŸŽ¶","ðŸŽ·","ðŸŽ¸","ðŸŽ¹","ðŸŽº","ðŸŽ»","ðŸŽ¼","ðŸŽ½","ðŸŽ¾","ðŸŽ¿","ðŸ€","ðŸ","ðŸ‚","ðŸƒ","ðŸ„","ðŸ…","ðŸ†","ðŸ‡","ðŸˆ","ðŸ‰","ðŸŠ","ðŸ‹","ðŸŒ","ðŸ","ðŸŽ","ðŸƒ","ðŸ","ðŸ‘","ðŸ’","ðŸ“","ðŸ”","ðŸ•","ðŸ–","ðŸ—","ðŸ˜","ðŸ™","ðŸš","ðŸ›","ðŸœ","ðŸ","ðŸ—ž","ðŸ“Ÿ","ðŸ› ","ðŸ›¡","ðŸ›¢","ðŸ›£","ðŸ›¤","ðŸ›¥","ðŸ¦","ðŸ§","ðŸ¨","ðŸ©","ðŸª","ðŸ«","ðŸ¬","ðŸ­","ðŸ®","ðŸ¯","ðŸ°","ðŸ“±","ðŸ“²","ðŸ³","ðŸ´","ðŸµ","ðŸ“¶","ðŸ·","ðŸ¸","ðŸ¹","ðŸº","ðŸ“»","ðŸ“¼","ðŸ“½","ðŸ—¾","ðŸ“¿"]

let def shuffle(a)
  let i = a:length - 1
  while i > 0
    let j = Math.floor(Math.random() * (i + 1))
    a[i], a[j] = a[j], a[i]
    i -= 1
  a

let def new_game(size)
  let result = []
  while result:length < size
    let j = Math.floor(Math.random() * emoji:length)
    let e = emoji[j]
    unless result.includes(e)
      result.push(e)

  shuffle([*result, *result]).map do |e|
    { emoji: e, state: "hidden" }

tag Tile
  def onclick
    return unless data:state == "hidden"
    trigger('tile', data)

  def render
    <self.tile .hidden=(data:state == "hidden")>
      if data:state == "hidden"
        " "
      else
        data:emoji

tag Game
  def game_won
    data:tiles.every do |e|
      e:state == "known"

  def ontile(event, tile)
    if data:first == null
      data:first = tile
      tile:state = "first"
    else if data:second == null
      if data:first:emoji == tile:emoji
        data:first:state = "known"
        tile:state = "known"
        data:first = null
        if game_won
          trigger('won')
      else
        data:second = tile
        tile:state = "second"
    else
      data:first:state = "hidden"
      data:second:state = "hidden"
      data:first = tile
      data:second = null
      tile:state = "first"

  def render
    <self.game.{"size-{data:size}"}>
      for tile in data:tiles
        <Tile[tile]>

tag App
  def setup
    @playing = false

  def onwon
    @playing = false

  def start(size)
    let tiles = new_game(size * size / 2)
    @game = { tiles: tiles, first: null, second: null, size: size }
    @playing = true

  def render
    <self>
      <header>
        "Memory game"
      if @game
        <Game[@game]>
      unless @playing
        <div.button_bar>
          <div>
            "Start game:"
          <div>
            <button :click=(do start(2))>
              "2x2"
            <button :click=(do start(4))>
              "4x4"
            <button :click=(do start(6))>
              "6x6"

Imba.mount <App>
